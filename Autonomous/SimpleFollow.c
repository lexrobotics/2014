#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S2,     backSensor,     sensorSONAR)
#pragma config(Sensor, S3,     frontSensor,    sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     motorsRight,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motorsLeft,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float frontDistance = -1.0;	// last two distances from the wall
float frontDistancePrev;
float backDistance = -1.0;	// on both sides
float backDistancePrev;

float negativeF, neutralF, positiveF;	// membership grades for the three front sonar fuzzy input sets
float negativeB, neutralB, positiveB;	// membership grades for the three back sonar fuzzy input sets

void getDistances()
{
		ClearTimer(T3);
		frontDistancePrev = frontDistance;
		frontDistance = SensorValue[frontSensor] / 2.54;
		if (abs(frontDistance - frontDistancePrev) > 10 && frontDistancePrev > 0)
				frontDistance = frontDistancePrev;
		nxtDisplayCenteredTextLine(0, "%f", frontDistance);

		backDistancePrev = backDistance;
		backDistance = SensorValue[backSensor] / 2.54;
		if (abs(backDistance - backDistancePrev) > 10 && backDistancePrev > 0)
				backDistance = backDistancePrev;
		nxtDisplayCenteredTextLine(1, "%f", backDistance);
    wait1Msec(100 - time1[T3]);
}

float bindValue(float value)
{
    if (value > 1)
        return 1.0;
    if (value < 0)
        return 0.0;
    return value;
}

void fuzzify()
{
    float fDist = frontDistance;
    float bDist = backDistance;

    negativeF = (18 - fDist) / 3;
    negativeF = bindValue(negativeF);
    neutralF = 1 - abs(18 - fDist) / 1.5;
    neutralF = bindValue(neutralF);
    positiveF = (fDist - 18) / 3;
    positiveF = bindValue(positiveF);

    negativeB = (18 - bDist) / 3;
    negativeB = bindValue(negativeB);
    neutralB = 1 - abs(18 - bDist) / 1.5;
    neutralB = bindValue(neutralB);
    positiveB = (bDist - 18) / 3;
    positiveB = bindValue(positiveB);
}

float applySetsAndDefuzzify()
{
    float numerator = negativeF * 1.5 + neutralF + positiveF * 0.5 + negativeB * 1.5 + neutralB + positiveB * 0.5;
    float denominator = negativeF + neutralF + positiveF + negativeB + neutralB + positiveB;
    return numerator / denominator;
}

void runMotors(float turnRatio)
{
    int leftSpeed = (int)((2 - turnRatio) * 25 + 0.5);
    int rightSpeed = (int)(turnRatio * 25 + 0.5);
    nxtDisplayCenteredTextLine(3, " leftSpeed: %d", leftSpeed);
    nxtDisplayCenteredTextLine(4, "rightSpeed: %d", rightSpeed);
    motor[motorsLeft] = leftSpeed;
    motor[motorsRight] = rightSpeed;
}

void fuzzyFollow()
{
    getDistances();
    fuzzify();
    float turnRatio = applySetsAndDefuzzify();
    nxtDisplayCenteredTextLine(5, "turnRatio: %f", turnRatio);
    runMotors(turnRatio);
}

task main()
{
		while (SensorValue[frontSensor] > 150 || SensorValue[backSensor] > 150)
		{
				motor[motorsLeft] = 25;
				motor[motorsRight] = 25;
		}
		ClearTimer(T2);
    while (time1[T2] < 2000)
    {
        fuzzyFollow();
    }
    motor[motorsLeft] = 0;
    motor[motorsRight] = 0;
    wait1Msec(3000);
}
