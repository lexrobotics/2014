#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTServo,  none,     none)
#pragma config(Hubs,  S3, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          a,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          b,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          c,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorZ1,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorZ2,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorLeftBack, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorLeftFront, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     motorZ1Level2, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     motorZ2Level2, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S3_C1_1,     motorRightBack, tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S3_C1_2,     motorRightFront, tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S2_C2_1,    servoSliderRight,     tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C2_2,    servoPusherRight,     tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C2_3,    servoSliderLeft,      tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C2_4,    servoPusherLeft,      tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C2_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo12,              tServoNone)
#pragma config(Servo,  srvo_S3_C2_1,    servoIR,              tServoStandard)
#pragma config(Servo,  srvo_S3_C2_2,    servoLifter2,         tServoContinuousRotation)
#pragma config(Servo,  srvo_S3_C2_3,    servoToasterTilt,     tServoStandard)
#pragma config(Servo,  srvo_S3_C2_4,    servoLifter,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S3_C2_5,    servoRampTrigger1,    tServoStandard)
#pragma config(Servo,  srvo_S3_C2_6,    servoRampTrigger2,    tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

 /* TeleOp.c
	* 2 Bits and a Byte
	* Author: Edward Shin
	*	Last Modified: 3/12/2013
	* Modified By: Noah
	* Modification: Cleaned up code, new comments
	*/

#include "JoystickDriver.c"
//#include "drivers/hitechnic-sensormux.h"
//#include "drivers/hitechnic-gyro.h"

static int TOP_HAT_FWDBACK_SPEED = 20;
static int TOP_HAT_TURN_SPEED = 20;
static int BURNOUT_TIME=5000;//burnout time in ms

/*  Controller 1
 *  --Left Joystick Up/Down: Forward/Backward Speed
 *  --Right Joystick Left/Right: Turn Speed
 *  --Button 5: Raise the chasis level 1 -- CTRL-F Raise1
 *  --Button 7: Lower the chasis level 1

 *  --Button 6: Raise the chassis level 2 -- CTRL-F Raise2
 *  --Button 8: Lower the chassis level 2

 *  --Button 4: Raise the toaster -- CTRL-F RaiseToaster
 *  --Button 2: Lower the toaster

 *  --Button 1: Reset the toaster -- CTRL-F TiltToaster
 *  --Button 3: Tilt the toaster

 *  *--Button 10: When held, use the D-Pad/Top Hat to drive at a constant, slow speed
 *
 *  Controller 2
 *  --Button 1: Left pusher left -- CTRL-F LeftPusher
 *  --Button 3: Left pusher right
 *  --Button D-pad left: Right pusher left -- CTRL-F RightPusher
 *  --Button D-pad right: Right pusher right
 *  --Button 6: Right slider forwards  -- CTRL-F RightSlider
 *  --Button 8: Right slider backwards
 *  --Button 5: Left slider forwards -- CTRL-F LeftSlider
 *  --Button 7: Left slider backwards
 *  --Button 9: Lower the ramp trigger -- CTRL-F TriggerRamp
 *  --Button 10: If pushed with 9, raise the ramp trigger
 *
 *
 *
 *
 */
void initializeRobot()
{
	nPidUpdateInterval = 8;
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorD] = mtrSpeedReg;
	servo[servoLifter] = 127;
	servo[servoLifter2] = 127;
	servo[servoSliderLeft] = 127;   //Slider slides back and forth
	servo[servoSliderRight] = 127;
	servo[servoPusherLeft] = 127; //Pusher pushes outward and inward
	servo[servoPusherRight] = 127;
	servo[servoRampTrigger1] = 0;//labeled 5 on the robot
	servo[servoRampTrigger2] = 0;//labeled 6
	servo[servoToasterTilt] = 140;
}

//Moves arm
task arm() {
	/*servo[servoLifter] = 127;                     //I think this isn't needed, was part of the servo twitch testing
	servo[servoSliderLeft] = 127;   //Slider slides back and forth
	servo[servoSliderRight] = 127;
	servo[servoPusherLeft] = 127; //Pusher pushes outward and inward
	servo[servoPusherRight] = 127;
	servo[servoRampTrigger1] = 60;
	servo[servoRampTrigger2] = 90;*/
	int ramp=255;
	while(true){
		getJoystickSettings(joystick);

		//RaiseToaster
		if(joy1Btn(4) == 1){
		  servo[servoLifter]=255;
		  servo[servoLifter2]=0;
		  wait1Msec(5);
		}

		else if(joy1Btn(2) == 1){
			servo[servoLifter]=0;
			servo[servoLifter2]=255;
			wait1Msec(5);
		}
		else {
			servo[servoLifter]=127;
			servo[servoLifter2]=127;
		}

		//TiltToaster
		if(joy1Btn(1) == 1){//Reset
			servo[servoToasterTilt] = 170;
			wait1Msec(5);
		}

		else if(joy1Btn(3) == 1){//Tilt
			servo[servoToasterTilt] = 240;
			wait1Msec(5);
		}


		//LeftSlider
		if(joy2Btn(3) == 1){
			servo[servoSliderLeft] = 0;
			wait1Msec(5);
		}

		else if(joy2Btn(1) == 1){
			servo[servoSliderLeft] = 255;
			wait1Msec(5);
		}
		else servo[servoSliderLeft] = 127;

		//RightSlider
		if(joystick.joy2_TopHat == 2){
			servo[servoSliderRight] = 0;
			wait1Msec(5);
		}

		else if(joystick.joy2_TopHat == 6){
			servo[servoSliderRight] = 255;
			wait1Msec(5);
		}
		else servo[servoSliderRight] = 127;

		//LeftPusher
		if(joy2Btn(2) == 1){
			servo[servoPusherLeft] = 255;
			wait1Msec(5);
		}

		else if(joy2Btn(4) == 1){
			servo[servoPusherLeft] = 0;
			wait1Msec(5);
		}
		else servo[servoPusherLeft] = 127;

		//RightPusher
		if(joystick.joy2_TopHat == 4){
			servo[servoPusherRight] = 0;
			wait1Msec(5);
		}

		else if(joystick.joy2_TopHat == 0){
			servo[servoPusherRight] = 255;
			wait1Msec(5);
		}
		else servo[servoPusherRight] = 127;

		//Ramp deployment
		/*if(joy2Btn(9)==1 && joy2Btn(10)==0){
			servo[servoRampTrigger1] = 150;
			servo[servoRampTrigger2] = 255;
		} */

		//TriggerRamp
		if(joy1Btn(10)==1)// && joy2Btn(9)==1){ //12345              make these controlled up and down buttons
		{
			ramp=0;
			servo[servoRampTrigger1]=255-ramp;
			servo[servoRampTrigger2]=ramp;
			wait1Msec(5);
		}
		else if (joy1Btn(9)==1)
		{
			ramp=255;
			servo[servoRampTrigger1]=255-ramp;
			servo[servoRampTrigger2]=ramp;
			wait1Msec(5);
		}

		//Raise1
		if(joy1Btn(5) == 1){
			motor[motorZ1] = 100;
			motor[motorZ2] = 100;
		}

		else if(joy1Btn(7) == 1){
			motor[motorZ1] = -100;
			motor[motorZ2] = -100;
		}

		else {
			motor[motorZ1] = 0;
			motor[motorZ2] = 0;
		}

		//Raise2
		if(joy2Btn(6) == 1){
			motor[motorZ1Level2] = 100;
			motor[motorZ2Level2] = 100;
		}

		else if(joy2Btn(8) == 1){
			motor[motorZ1Level2] = -100;
			motor[motorZ2Level2] = -100;
		}

		else {
			motor[motorZ1Level2] = 0;
			motor[motorZ2Level2] = 0;
		}

	}
}
//const tMUXSensor gyroSensor = msensor_S3_2;
//const tMUXSensor irSeekerSensor = msensor_S3_4;
//const tMUXSensor lightSensor = msensor_S3_1;

task main() {

	int motorRFtemp = 0;
	int motorRBtemp = 0;
	int motorLFtemp = 0;
	int motorLBtemp = 0;
	int changed;
	float joyY1;
	float joyX2;
	float prevJoyY1;
	float prevJoyX2;
	float prevTopHat;
	float gyro;


	int offset = 0;

	writeDebugStreamLine("");
	writeDebugStreamLine("TELEOP");

	// Initialize servos and set to initial positions
	initializeRobot();
	writeDebugStreamLine("Initialized");

	// Wait for start of tele-op phase
	waitForStart();
	writeDebugStreamLine("Begin!");

	StartTask(arm);
  ClearTimer(T1);
  ClearTimer(T2); //using timer as burnout timer
	while(true) {
		getJoystickSettings(joystick);
		if (joy1Btn(10))
			{
			int pwrR=0;
			int pwrL=0;
      if (joystick.joy1_TopHat == 0) {  // forward
        pwrL = TOP_HAT_FWDBACK_SPEED;
        pwrR = TOP_HAT_FWDBACK_SPEED;
      } else if (joystick.joy1_TopHat == 4) { // backward
        pwrL = -1 * TOP_HAT_FWDBACK_SPEED;
        pwrR = -1 * TOP_HAT_FWDBACK_SPEED;
      } else if (joystick.joy1_TopHat == 2) { // right
        pwrL = TOP_HAT_TURN_SPEED;
        pwrR = -1 * TOP_HAT_TURN_SPEED;
      } else if (joystick.joy1_TopHat == 6) { // left
        pwrL = -1 * TOP_HAT_TURN_SPEED;
        pwrR = TOP_HAT_TURN_SPEED;
      }
      motorRFtemp=pwrR;
      motorRBtemp=pwrR;
      motorLFtemp=pwrL;
      motorLBtemp=pwrL;
    }

    if(!joy1Btn(10))
    {
			//Set analog joystick deadzone
			if(abs(joystick.joy1_y1) < 10)
				joyY1 = 0;
			else
				joyY1 = joystick.joy1_y1;
			if(abs(joystick.joy1_x2) < 10)
				joyX2 = 0;
			else
				joyX2=joystick.joy1_x2;

			eraseDisplay();
			nxtDisplayCenteredTextLine(1,"Y4: %4d",joyY1);
			nxtDisplayCenteredTextLine(2,"X: %4d",joyX2);

			motorRFtemp = 0.7874*(joyY1 - joyX2/1); //change the 1 to a greater number to make the robot turn slower, but more accurately.
			motorLFtemp = 0.7874*(joyY1 + joyX2/1);
			motorRBtemp = 0.7874*(joyY1 - joyX2);
			motorLBtemp = 0.7874*(joyY1 + joyX2);
		}
		/*if(joy1Btn(10) && prevTopHat!=joystick.joy1_TopHat)
		{
			ClearTimer(T2);
		}
		if(!joy1Btn(10) && (prevJoyX2!=joyX2||prevJoyY1!=joyY1))
		{
			ClearTimer(T2);
		}*/

		prevJoyY1=joyY1;
		prevJoyX2=joyX2;
		prevTopHat=joystick.joy1_TopHat;

		/*if(time1[T2]>=BURNOUT_TIME)
		{
			motor[motorRightFront] = 0;
			motor[motorLeftFront] = 0;
			motor[motorRightBack] = 0;
			motor[motorLeftBack] = 0;
	  }*/

		  motor[motorRightFront] = motorRFtemp;
			motor[motorLeftFront] = motorLFtemp;
			motor[motorRightBack] = motorRBtemp;
			motor[motorLeftBack] = motorLBtemp;

	}
}
