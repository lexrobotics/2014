#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          gun,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     dualWheels,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorsRight,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorsLeft,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     lift1,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     lift2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     flagMotor,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    rampTilt,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    singleWheel,          tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_3,    flagExtender,         tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_4,    singleWheelTilt,      tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c" //library with joystick controls

static float MOTOR_SCALE = 200.0/256.0; //since joystick values range from -128 to 127 and motors from -100 to 100, we need to scale values from the joystick

void initialize() {
	servo[rampTilt] = 127;
	servo[singleWheelTilt]  = 127;
}

//This is the task where we define all servo/"arm" movements.
//By separating the arm and drive tasks, it lets us logically separate our code, and run each one in parallel.
//e.g. you can raise your arm while driving at the same time
task arm() {
	//define servo-position related variables here

	while(true){
		getJoystickSettings(joystick); //grab snapshot of controller positions
		if(joy1Btn(1)){//  gun (for test purposes)
			motor[gun] = 100;
		}
		else if(joy1Btn(3)){
			motor[gun] = - 100;
		}
		else{
			motor[gun]  = 0;
		}

		if(joy1Btn(2)){//controls ramp angle using joy1's buttons 2 and 4
			servo[rampTilt] -= 1;
		}
		else if(joy1Btn(4)){
			servo[rampTilt] += 1;
		}

		if (joystick.joy1_TopHat == 0) {  //controls singleWheel angle using joy1's Control Pad
			servo[singleWheelTilt] -= 1;
		}
		else if (joystick.joy1_TopHat == 4) {
			servo[singleWheelTilt] += 1;
		}

		if(joy1Btn(5)){	//controls singleWheel using joy1's Buttons Left Triggers
			servo[singleWheel] = 240;
		}
		else if(joy1Btn(7)){
			servo[singleWheel] = 127;
		}

		if(joy1Btn(6)){					//activates dualWheels and singleWheel using joy1's Right Triggers
			motor[dualWheels] = -60;//bringing in or shooting out blocks
			servo[singleWheel]  = 30;
		}
		else if(joy1Btn(8)){
			motor[dualWheels] = 0;
			servo[singleWheel] = 127;
		}

		if(joy2Btn(1)){// flagExtender is controlled using joy2's buttons 1 and 3
			servo[flagExtender] = 255;
		}
		else if(joy2Btn(3)){
			servo[flagExtender] = 0;
		}
		else {
			servo[flagExtender]  = 127;
		}

		if(joy2Btn(2)){//spin dat flag using joy2's buttons 2 and 4
			motor[flagMotor] = 100;
		}
		else if(joy1Btn(4)){
			motor[flagMotor] = -100;
		}
		else {
			motor[flagMotor] = 0;
		}

		if(joy2Btn(5)){					//controls lift1 using joy2's left triggers
			motor[lift1] = 100;
		}
		else if(joy2Btn(7)){
			motor[lift1] = -100;
		}
		else{
			motor[lift1] = 0;
		}

		if(joy2Btn(6)){					//controls lift2 using joy2's right triggers
			motor[lift2] = 100;
		}
		else if(joy2Btn(8)){
			motor[lift2] = -100;
		}
		else{
			motor[lift2] = 0;
		}
	}
}

task main() {
	//variables for motor power that we can modify before feeding to motors
	int powerRight = 0;
	int powerLeft = 0;

	writeDebugStreamLine("");
	writeDebugStreamLine("TELEOP");

	// Initialize robot actuators
	initialize();

	// Wait for start of tele-op phase
	waitForStart();
	writeDebugStreamLine("Begin!");

	StartTask(arm); //start running "arm" task in parallel
	ClearTimer(T1);

	while(true) {
		getJoystickSettings(joystick); //grab snapshot of controller positions

		//Since joysticks rarely settle to zero, this makes sure each axis is reset to 0 even if it's within 10 from zero
		//Be sure to copy one of these statements for each joystick you use
		if(abs(joystick.joy1_y1) < 10)
			joystick.joy1_y1 = 0;
		if(abs(joystick.joy1_y2) < 10)
			joystick.joy1_y2 = 0;

		powerRight = MOTOR_SCALE*joystick.joy1_y2;
		powerLeft = MOTOR_SCALE*joystick.joy1_y1;

		motor[motorsRight] = powerRight;
		motor[motorsLeft] = powerLeft;
	}
}
