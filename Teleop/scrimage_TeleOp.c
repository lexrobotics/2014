#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorsRight,   tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     pulleyMotor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     flagMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     hangingMotor,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorsLeft,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     harvestMotor,  tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    gun,                  tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    flagExtender,         tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_3,    harvestLifter,        tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //library with joystick control methods

//static speed of robot in precision mode
static int TOP_HAT_FWDBACK_SPEED = 20;
static int TOP_HAT_TURN_SPEED = 20;

static float MOTOR_SCALE = 200.0/256.0; //since joystick values range from -128 to 127 and motors from -100 to 100, we need to scale values from the joystick

void initializeRobot()
{
	//These 3 lines set up PID control for the drive motors (using encoders)
	nPidUpdateInterval = 8;
	nMotorPIDSpeedCtrl[motorsRight] = mtrSpeedReg; //Copy this line (with motor name changed) for each motor you set up with an encoder
	nMotorPIDSpeedCtrl[motorsLeft] = mtrSpeedReg;

	//define starting position for servos here
}

//This is the task where we define all servo/"arm" movements.
//By separating the arm and drive tasks, it lets us logically separate our code, and run each one in parallel.
//e.g. you can raise your arm while driving at the same time
task arm() {
	//define servo-position related variables here

	while(true){
		getJoystickSettings(joystick); //grab snapshot of controller positions

		if (joy1Btn(2))//moves harvester down
			servo[harvestLifter] = 255;
		else if(joy1Btn(4))//moves harvester up
			servo[harvestLifter] = 0;
		else
			servo[harvestLifter] = 127;

		if(joy1Btn(6))//if right front trigger is pressed, harvestMotor is powered, harvesting blocks with the roller thing in the front.
			motor[harvestMotor] = -100; //out
		else if(joy1Btn(8))
			motor[harvestMotor] = 100; //in
		else
			motor[harvestMotor] = 0;

		if(joy2Btn(5))//if left front trigger is pressed, flagMotor is powered, spinning in order to turn the flag raising thing
			motor[flagMotor] = -100;
		else if(joy2Btn(7))//if left back trigger is pressed, flagMotor is powered, spinning in the opposite direction
			motor[flagMotor] = 100;
		else
			motor[flagMotor] = 0;

		if(joy2Btn(6))
<<<<<<< HEAD
			motor[hangingMotor] = 100;
		else if(joy2Btn(8))
=======
			motor[pulleyMotor] = 100;
		else if(joy2Btn(8))
			motor[pulleyMotor] = -100;
		else
			motor[pulleyMotor] = 0;

		if(joy2Btn(5)){
			motor[hangingMotor] = 100;
			motor[pulleyMotor] = -90;
		}
		else if(joy2Btn(7)) {
>>>>>>> Added FinalTeleOp.c for Robot number A
			motor[hangingMotor] = -100;
			motor[pulleyMotor] = 100;
		}
		else if(joy2Btn(6)) {
			motor[hangingMotor] = 0;
			motor[pulleyMotor] = 100;
		}
		else if(joy2Btn(8)) {
			motor[hangingMotor] = 0;
			motor[pulleyMotor] = -100;
		}
		else {
			motor[hangingMotor] = 0;
			motor[pulleyMotor] = 0;
		}


		if (joystick.joy2_TopHat == 0) {  // forward
			motor[pulleyMotor] = 100;
		}
		else if (joystick.joy2_TopHat == 4) { // backward
			motor[pulleyMotor] = -100;
		}
		else
			motor[pulleyMotor] = 0;

		if(joy2Btn(2))//retracts the flag raiser
			servo[flagExtender] = 255;
		else if(joy2Btn(4))//extends the flag raiser
			servo[flagExtender] = 0;
		else
			servo[flagExtender] = 127;

	}
}

task main() {
	//variables storing intermediate values for motor power before actually feeding it to motors
	int powerRight = 0;
	int powerLeft = 0;

	writeDebugStreamLine("");
	writeDebugStreamLine("TELEOP");

	// Initialize robot actuators
	initializeRobot();
	writeDebugStreamLine("Initialized");

	// Wait for start of tele-op phase
	waitForStart();
	writeDebugStreamLine("Begin!");

	StartTask(arm); //start running "arm" task in parallel
	ClearTimer(T1);

	while(true) {
		getJoystickSettings(joystick); //grab snapshot of controller positions

		if (joy1Btn(1))
		{
			powerLeft = 0;
			powerRight = 0;

			//Tophat direction values:
			//  0
			//6   2
			//  4
			//sin(2pi*joystick.joy1_TopHat/8)

			if (joystick.joy1_TopHat == 0) {  // forward
				powerLeft = TOP_HAT_FWDBACK_SPEED;
				powerRight = TOP_HAT_FWDBACK_SPEED;
			}
			else if (joystick.joy1_TopHat == 4) { // backward
				powerLeft = -1 * TOP_HAT_FWDBACK_SPEED;
				powerRight = -1 * TOP_HAT_FWDBACK_SPEED;
			}
			else if (joystick.joy1_TopHat == 2) { // right
				powerLeft = TOP_HAT_TURN_SPEED;
				powerRight = -1 * TOP_HAT_TURN_SPEED;
			}
			else if (joystick.joy1_TopHat == 6) { // left
				powerLeft = -1 * TOP_HAT_TURN_SPEED;
				powerRight = TOP_HAT_TURN_SPEED;
			}
		}
		else
		{
			//Since joysticks rarely settle to zero, this makes sure each axis is reset to 0 even if it's within 10 from zero
			//Be sure to copy one of these statements for each joystick you use
			if(abs(joystick.joy1_y1) < 10)
				joystick.joy1_y1 = 0;
			if(abs(joystick.joy1_y2) < 10)
				joystick.joy1_y2 = 0;

			powerRight = MOTOR_SCALE*joystick.joy1_y2;
			powerLeft = MOTOR_SCALE*joystick.joy1_y1;
		}

		motor[motorsRight] = powerRight;
		motor[motorsLeft] = powerLeft;
	}
}
